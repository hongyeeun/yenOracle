-- 6일차 서브쿠러ㅣ

-- 1.2.5 상(호연)관 서브쿼리
-- - 메인쿼리의 값이 서브쿼리에 사용되는 것
-- - 메인쿼리의 값을 서브쿼리에 주고 서브쿼리를 수행한 다음 그 결과를 다시 메인쿼리로 반환해서 수행하는 것
-- - 상호연관 관계를 가지고 실행하는 쿼리이다.

SELECT * FROM EMPLOYEE E WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEE WHERE SALARY > E.SALARY); --전동일

-- @실습문제4
-- 직급이 J1, J2, J3 이 아닌 사원 중에서 자신의 부서별 평균급여보다 많은 급여를 받는
-- 직원의 부서코드, 사원명, 급여, (부서별 급여평균) 정보를 출력하시오.
SELECT DEPT_CODE, EMP_NAME, SALARY, (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE) "부서별 평균 급여"
FROM EMPLOYEE E
WHERE JOB_CODE NOT IN ('J1', 'J2', 'J3')    -- DEPT_CODE 를 없애면, 모든 DEPT_CODE 일때가 나온다.
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE);

SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D6'; -- 부서별 급여 평균을 구하는 식 (이때는 DEPT_CODE가 6일때임)
-- 모든 DEPT_CODE로 하고 싶을 때는, 이 EMPLOYEE 의 DEPT_CODE 로 치환해주면 되므로 
-- EMPLOYEE에 별칭을 부여한 후에 E.DEPT_CODE라고 적어준다.

-- 이렇게 다 하나씩 할 수 있는데 이걸 DEPT_CODE를 생략해주고
-- 서브쿼리에서 DEPT_CODE는 E.DEPT_CODE로 해준다.
SELECT DEPT_CODE, EMP_NAME, SALARY, SALARY
FROM EMPLOYEE
WHERE JOB_CODE NOT IN ('J1', 'J2', 'J3') AND DEPT_CODE ='D5' 
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D5');

SELECT DEPT_CODE, EMP_NAME, SALARY, SALARY
FROM EMPLOYEE
WHERE JOB_CODE NOT IN ('J1', 'J2', 'J3') AND DEPT_CODE ='D6' 
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D6');

SELECT DEPT_CODE, EMP_NAME, SALARY, SALARY
FROM EMPLOYEE
WHERE JOB_CODE NOT IN ('J1', 'J2', 'J3') AND DEPT_CODE ='D1' 
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D1');

SELECT DEPT_CODE, EMP_NAME, SALARY, SALARY
FROM EMPLOYEE
WHERE JOB_CODE NOT IN ('J1', 'J2', 'J3') AND DEPT_CODE ='D2' 
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D2');

-- 1.2.6 스칼라 서브쿼리
-- 결과값이 1개인 상관서브쿼리, SELECT문 뒤에 사용됨.
-- SQL에서 단일값을 스칼라값이라고 함.

-- @실습문제1
-- 사원명, 부서명, 부서의 평균임금(자신이 속한 부서의 평균임금)을 스칼라 서브쿼리를 이용해서
-- 출력하세요.
SELECT EMP_NAME, DEPT_TITLE, (SELECT FLOOR(AVG(SALARY))  FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE) "부서별 평균임금"
FROM EMPLOYEE E
LEFT OUTER JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;



-- @실습문제2
-- 모든 직원의 사번, 이름, 소속부서를 조회한 후 부서명을 오름차순으로 정렬하시오.
-- JOIN을 하지 않고 스칼라 서브쿼리로 해보자.
SELECT EMP_ID, EMP_NAME, (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID = E.DEPT_CODE) "DEPT_TITLE" 
FROM EMPLOYEE E
ORDER BY DEPT_TITLE ASC;
-- ORDER BY 이후 DEPT_TITLE에 (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID = E.DEPT_CODE) 이렇게 해도 된다.

-- 서브쿼리
SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID = 'D5';
--  (이때는 DEPT_ID가 'D5'일때 이므로, 각각의 DEPT_ID를 나타내기 위해서는 E.DEPT_CODE로 해줘야한다)

-- @실습문제3
-- 직급이 J1이 아닌 사원 중에서 자신의 부서 평균급여보다 적은 급여를 받는 사원출력하시오
-- 부서코드, 사원명, 급여, 부서의 급여평균을 출력하시오.
SELECT DEPT_CODE, EMP_NAME, SALARY
, (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE) "부서의 급여평균"
FROM EMPLOYEE E
WHERE JOB_CODE != 'J1'
AND SALARY > (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE);

-- @실습문제4
-- 자신이 속한 직급의 평균급여보다 많이 받는 직원의 이름, 직급, 급여를 출력하시오.
SELECT EMP_NAME, (SELECT JOB_NAME FROM JOB WHERE JOB_CODE = E.JOB_CODE) "JOB_NAME", SALARY
FROM EMPLOYEE E
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE JOB_CODE = E.JOB_CODE);