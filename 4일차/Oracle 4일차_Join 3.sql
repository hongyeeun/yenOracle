-- 4일차 오라클 조인
-- 두 개 이상의 테이블에서 연관성을 가지고 있는 데이터들을 따로 분류하여 
--새로운 가상의 테이블을 이용하여 출력함. 
-- -> 여러 테이블의 레코드를 조합하여 하나의 열로 표현 한 것

-- ANSI 표준 구문
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_ID, DEPT_TITLE 
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID;
-- DEPARTMENT와 JOIN 해준다. ON은 연관 데이터 기준
-- EMPLOYEE 에선 EMP_ID~ DEPT_CODE만 출력가능했는데 JOIN 하였으므로
-- DEPT_ID, DEPT_TITLE도 출력할 수 있게 된다.
-- 조인할때, 칼럼명이 달라도 연관된 데이터가 
-- 데이터 값이 같으면 JOIN 해서 옆에 나열해준다.

-- 오라클 전용 구문
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_ID, DEPT_TITLE 
FROM EMPLOYEE
, DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID;
-- FROM 테이블1, 테이블2 WHERE 컬럼1명 = 컬럼2명;

SELECT DEPT_ID, DEPT_TITLE FROM DEPARTMENT;

-- 두 테이블의 컬럼명이 서로 같을 때 (구별 해줘야 함)
-- ANSI 표준 구문
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB.JOB_CODE, JOB_NAME 
FROM EMPLOYEE
JOIN JOB
ON EMPLOYEE.JOB_CODE = JOB.JOB_CODE;

-- 테이블에 별칭 부여 -> E, J
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, J.JOB_CODE, JOB_NAME 
FROM EMPLOYEE E
JOIN JOB J
ON E.JOB_CODE = J.JOB_CODE;

-- 조인하는 컬럼 같을 때 USING 구문도 사용 가능
SELECT EMP_ID, EMP_NAME, JOB_NAME, JOB_CODE
FROM EMPLOYEE E
JOIN JOB J
USING(JOB_CODE);

-- 오라클 전용 구문
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB.JOB_CODE, JOB_NAME 
FROM EMPLOYEE
, JOB
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;

-- @실습문제1
-- 부서명과 지역명을 출력하세요.
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT
JOIN LOCATION
ON LOCATION_ID = LOCAL_CODE;

-- @실습문제2
-- 사원명과 직급명을 출력하세요!
SELECT EMP_NAME, JOB_NAME
FROM EMPLOYEE
JOIN JOB
USING(JOB_CODE);

SELECT EMP_NAME, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J
ON E.JOB_CODE = J.JOB_CODE;

-- @실습문제3
-- 지역명과 국가명을 출력하세요
SELECT LOCAL_NAME, NATIONAL_NAME
FROM NATIONAL
JOIN LOCATION
USING(NATIONAL_CODE);

-- @JOIN 종합실습
--1. 주민번호가 1970년대 생이면서 성별이 여자이고, 
-- 성이 전씨인 직원들의 사원명, 주민번호, 부서명, 직급명을 조회하시오.
SELECT EMP_NAME, EMP_NO, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE E
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE)
WHERE (EMP_NAME LIKE '전%') AND (EMP_NO LIKE '7%-2%');

--2. 이름에 '형'자가 들어가는 직원들의 사번, 사원명, 부서명을 조회하시오.
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT
ON DEPT_CODE = DEPT_ID
WHERE EMP_NAME LIKE '%형%';

--3. 해외영업부에 근무하는 사원명, 직급명, 부서코드, 부서명을 조회하시오.
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, JOB_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE E
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE)
JOIN LOCATION ON(LOCAL_CODE = LOCATION_ID)
WHERE NATIONAL_CODE NOT IN 'KO';

--4. 보너스포인트를 받는 직원들의 사원명, 보너스포인트, 부서명, 근무지역명을 조회하시오.
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;

SELECT EMP_NAME, BONUS, DEPT_TITLE, NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE BONUS IS NOT NULL;

--5. 부서코드가 D2인 직원들의 사원명, 직급명, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME, JOB_NAME, DEPT_TITLE, NATIONAL_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE DEPT_CODE = 'D2';

--6. 급여등급테이블의 최대급여(MAX_SAL)보다 많이 받는 직원들의 사원명, 직급명, 급여, 연봉을 조회하시오.
-- (사원테이블과 급여등급테이블을 SAL_LEVEL컬럼기준으로 조인할 것)
-- 데이터 없음!
SELECT * FROM SAL_GRADE;

SELECT EMP_NAME, JOB_NAME, SALARY, SALARY*12 "연봉"
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN SAL_GRADE USING(SAL_LEVEL)
WHERE SALARY>MAX_SAL;

--7. 한국(KO)과 일본(JP)에 근무하는 직원들의 사원명, 부서명, 지역명, 국가명을 조회하시오.
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN LOCATION ON(LOCAL_CODE = LOCATION_ID)
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE NATIONAL_CODE = 'KO' OR NATIONAL_CODE='JP';

--8. 보너스포인트가 없는 직원들 중에서 직급이 차장과 사원인 직원들의 사원명, 직급명, 급여를 조회하시오. 
--단, join과 IN 사용할 것
SELECT * FROM DEPARTMENT;
SELECT * FROM sal_grade;
SELECT * FROM JOB;

SELECT EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN JOB USING(JOB_CODE)
JOIN SAL_GRADE USING(SAL_LEVEL)
WHERE BONUS IS NULL AND JOB_NAME IN '차장';

--9. 재직중인 직원과 퇴사한 직원의 수를 조회하시오.
SELECT COUNT(*)
FROM EMPLOYE;